// This is generated by script, DO NOT edit it.

#ifndef BASE_CALLBACK_SPEC_H_
#define BASE_CALLBACK_SPEC_H_

#include "base/basictypes.h"

namespace base {

class Closure {
 public:
  Closure() {}
  virtual ~Closure() {}
  virtual void Run() = 0;
 private:
  DISALLOW_COPY_AND_ASSIGN(Closure);
};

template <class R>
class ResultCallback {
 public:
  ResultCallback() {}
  virtual ~ResultCallback() {}
  virtual R Run() = 0;
 private:
  DISALLOW_COPY_AND_ASSIGN(ResultCallback);
};

template <bool del, class R, class T>
class _ConstMemberResultCallback_0_0 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)() const;
  inline _ConstMemberResultCallback_0_0(const T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual R Run() {
    R result = (object_->*member_)();
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_0_0);
};

template <bool del, class T>
class _ConstMemberResultCallback_0_0<del, void, T> : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)() const;
  inline _ConstMemberResultCallback_0_0(const T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual void Run() {
    (object_->*member_)();
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_0_0);
};

template <class T1, class T2, class R>
inline typename _ConstMemberResultCallback_0_0<true, R, T1>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)() const) {
  return new _ConstMemberResultCallback_0_0<true, R, T1>(obj, member);
}

template <class T1, class T2, class R>
inline typename _ConstMemberResultCallback_0_0<false, R, T1>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)() const) {
  return new _ConstMemberResultCallback_0_0<false, R, T1>(obj, member);
}

template <bool del, class R, class T>
class _MemberResultCallback_0_0 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)();
  inline _MemberResultCallback_0_0(T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual R Run() {
    R result = (object_->*member_)();
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_0_0);
};

template <bool del, class T>
class _MemberResultCallback_0_0<del, void, T> : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)();
  inline _MemberResultCallback_0_0(T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual void Run() {
    (object_->*member_)();
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_0_0);
};

template <class T1, class T2, class R>
inline typename _MemberResultCallback_0_0<true, R, T1>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)()) {
  return new _MemberResultCallback_0_0<true, R, T1>(obj, member);
}

template <class T1, class T2, class R>
inline typename _MemberResultCallback_0_0<false, R, T1>::base*
NewPermanentCallback(T1* obj, R (T2::*member)()) {
  return new _MemberResultCallback_0_0<false, R, T1>(obj, member);
}

template <bool del, class R>
class _FunctionResultCallback_0_0 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (*FunctionSignature)();
  inline _FunctionResultCallback_0_0(FunctionSignature function)
      : function_(function) {}

  virtual R Run() {
    R result = (*function_)();
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_0_0);
};

template <bool del>
class _FunctionResultCallback_0_0<del, void> : public Closure {
 public:
  typedef Closure base;
  typedef void (*FunctionSignature)();
  inline _FunctionResultCallback_0_0(FunctionSignature function)
      : function_(function) {}

  virtual void Run() {
    (*function_)();
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_0_0);
};

template <class R>
inline typename _FunctionResultCallback_0_0<true, R>::base*
NewOneTimeCallback(R (*function)()) {
  return new _FunctionResultCallback_0_0<true, R>(function);
}

template <class R>
inline typename _FunctionResultCallback_0_0<false, R>::base*
NewPermanentCallback(R (*function)()) {
  return new _FunctionResultCallback_0_0<false, R>(function);
}

template <class Arg1>
class Callback1 {
 public:
  Callback1() {}
  virtual ~Callback1() {}
  virtual void Run(Arg1) = 0;
 private:
  DISALLOW_COPY_AND_ASSIGN(Callback1);
};

template <class R, class Arg1>
class ResultCallback1 {
 public:
  ResultCallback1() {}
  virtual ~ResultCallback1() {}
  virtual R Run(Arg1) = 0;
 private:
  DISALLOW_COPY_AND_ASSIGN(ResultCallback1);
};

template <bool del, class R, class T, class Arg1>
class _ConstMemberResultCallback_0_1 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (T::*MemberSignature)(Arg1) const;
  inline _ConstMemberResultCallback_0_1(const T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual R Run(Arg1 arg1) {
    R result = (object_->*member_)(arg1);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_0_1);
};

template <bool del, class T, class Arg1>
class _ConstMemberResultCallback_0_1<del, void, T, Arg1> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (T::*MemberSignature)(Arg1) const;
  inline _ConstMemberResultCallback_0_1(const T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual void Run(Arg1 arg1) {
    (object_->*member_)(arg1);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_0_1);
};

template <class T1, class T2, class R, class Arg1>
inline typename _ConstMemberResultCallback_0_1<true, R, T1, Arg1>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1) const) {
  return new _ConstMemberResultCallback_0_1<true, R, T1, Arg1>(obj, member);
}

template <class T1, class T2, class R, class Arg1>
inline typename _ConstMemberResultCallback_0_1<false, R, T1, Arg1>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1) const) {
  return new _ConstMemberResultCallback_0_1<false, R, T1, Arg1>(obj, member);
}

template <bool del, class R, class T, class Arg1>
class _MemberResultCallback_0_1 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (T::*MemberSignature)(Arg1);
  inline _MemberResultCallback_0_1(T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual R Run(Arg1 arg1) {
    R result = (object_->*member_)(arg1);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_0_1);
};

template <bool del, class T, class Arg1>
class _MemberResultCallback_0_1<del, void, T, Arg1> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (T::*MemberSignature)(Arg1);
  inline _MemberResultCallback_0_1(T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual void Run(Arg1 arg1) {
    (object_->*member_)(arg1);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_0_1);
};

template <class T1, class T2, class R, class Arg1>
inline typename _MemberResultCallback_0_1<true, R, T1, Arg1>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1)) {
  return new _MemberResultCallback_0_1<true, R, T1, Arg1>(obj, member);
}

template <class T1, class T2, class R, class Arg1>
inline typename _MemberResultCallback_0_1<false, R, T1, Arg1>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1)) {
  return new _MemberResultCallback_0_1<false, R, T1, Arg1>(obj, member);
}

template <bool del, class R, class Arg1>
class _FunctionResultCallback_0_1 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (*FunctionSignature)(Arg1);
  inline _FunctionResultCallback_0_1(FunctionSignature function)
      : function_(function) {}

  virtual R Run(Arg1 arg1) {
    R result = (*function_)(arg1);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_0_1);
};

template <bool del, class Arg1>
class _FunctionResultCallback_0_1<del, void, Arg1> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (*FunctionSignature)(Arg1);
  inline _FunctionResultCallback_0_1(FunctionSignature function)
      : function_(function) {}

  virtual void Run(Arg1 arg1) {
    (*function_)(arg1);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_0_1);
};

template <class R, class Arg1>
inline typename _FunctionResultCallback_0_1<true, R, Arg1>::base*
NewOneTimeCallback(R (*function)(Arg1)) {
  return new _FunctionResultCallback_0_1<true, R, Arg1>(function);
}

template <class R, class Arg1>
inline typename _FunctionResultCallback_0_1<false, R, Arg1>::base*
NewPermanentCallback(R (*function)(Arg1)) {
  return new _FunctionResultCallback_0_1<false, R, Arg1>(function);
}

template <bool del, class R, class T, class Arg1>
class _ConstMemberResultCallback_1_1 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)(Arg1) const;
  inline _ConstMemberResultCallback_1_1(const T* object, MemberSignature member, Arg1 arg1)
      : object_(object), member_(member), arg1_(arg1) {}

  virtual R Run() {
    R result = (object_->*member_)(arg1_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg1 arg1_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_1_1);
};

template <bool del, class T, class Arg1>
class _ConstMemberResultCallback_1_1<del, void, T, Arg1> : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)(Arg1) const;
  inline _ConstMemberResultCallback_1_1(const T* object, MemberSignature member, Arg1 arg1)
      : object_(object), member_(member), arg1_(arg1) {}

  virtual void Run() {
    (object_->*member_)(arg1_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg1 arg1_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_1_1);
};

template <class T1, class T2, class R, class Arg1>
inline typename _ConstMemberResultCallback_1_1<true, R, T1, Arg1>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1) const, Arg1 arg1) {
  return new _ConstMemberResultCallback_1_1<true, R, T1, Arg1>(obj, member, arg1);
}

template <class T1, class T2, class R, class Arg1>
inline typename _ConstMemberResultCallback_1_1<false, R, T1, Arg1>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1) const, Arg1 arg1) {
  return new _ConstMemberResultCallback_1_1<false, R, T1, Arg1>(obj, member, arg1);
}

template <bool del, class R, class T, class Arg1>
class _MemberResultCallback_1_1 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)(Arg1);
  inline _MemberResultCallback_1_1(T* object, MemberSignature member, Arg1 arg1)
      : object_(object), member_(member), arg1_(arg1) {}

  virtual R Run() {
    R result = (object_->*member_)(arg1_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg1 arg1_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_1_1);
};

template <bool del, class T, class Arg1>
class _MemberResultCallback_1_1<del, void, T, Arg1> : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)(Arg1);
  inline _MemberResultCallback_1_1(T* object, MemberSignature member, Arg1 arg1)
      : object_(object), member_(member), arg1_(arg1) {}

  virtual void Run() {
    (object_->*member_)(arg1_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg1 arg1_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_1_1);
};

template <class T1, class T2, class R, class Arg1>
inline typename _MemberResultCallback_1_1<true, R, T1, Arg1>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1), Arg1 arg1) {
  return new _MemberResultCallback_1_1<true, R, T1, Arg1>(obj, member, arg1);
}

template <class T1, class T2, class R, class Arg1>
inline typename _MemberResultCallback_1_1<false, R, T1, Arg1>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1), Arg1 arg1) {
  return new _MemberResultCallback_1_1<false, R, T1, Arg1>(obj, member, arg1);
}

template <bool del, class R, class Arg1>
class _FunctionResultCallback_1_1 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (*FunctionSignature)(Arg1);
  inline _FunctionResultCallback_1_1(FunctionSignature function, Arg1 arg1)
      : function_(function), arg1_(arg1) {}

  virtual R Run() {
    R result = (*function_)(arg1_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  Arg1 arg1_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_1_1);
};

template <bool del, class Arg1>
class _FunctionResultCallback_1_1<del, void, Arg1> : public Closure {
 public:
  typedef Closure base;
  typedef void (*FunctionSignature)(Arg1);
  inline _FunctionResultCallback_1_1(FunctionSignature function, Arg1 arg1)
      : function_(function), arg1_(arg1) {}

  virtual void Run() {
    (*function_)(arg1_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  Arg1 arg1_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_1_1);
};

template <class R, class Arg1>
inline typename _FunctionResultCallback_1_1<true, R, Arg1>::base*
NewOneTimeCallback(R (*function)(Arg1), Arg1 arg1) {
  return new _FunctionResultCallback_1_1<true, R, Arg1>(function, arg1);
}

template <class R, class Arg1>
inline typename _FunctionResultCallback_1_1<false, R, Arg1>::base*
NewPermanentCallback(R (*function)(Arg1), Arg1 arg1) {
  return new _FunctionResultCallback_1_1<false, R, Arg1>(function, arg1);
}

template <class Arg1, class Arg2>
class Callback2 {
 public:
  Callback2() {}
  virtual ~Callback2() {}
  virtual void Run(Arg1, Arg2) = 0;
 private:
  DISALLOW_COPY_AND_ASSIGN(Callback2);
};

template <class R, class Arg1, class Arg2>
class ResultCallback2 {
 public:
  ResultCallback2() {}
  virtual ~ResultCallback2() {}
  virtual R Run(Arg1, Arg2) = 0;
 private:
  DISALLOW_COPY_AND_ASSIGN(ResultCallback2);
};

template <bool del, class R, class T, class Arg1, class Arg2>
class _ConstMemberResultCallback_0_2 : public ResultCallback2<R, Arg1, Arg2> {
 public:
  typedef ResultCallback2<R, Arg1, Arg2> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2) const;
  inline _ConstMemberResultCallback_0_2(const T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual R Run(Arg1 arg1, Arg2 arg2) {
    R result = (object_->*member_)(arg1, arg2);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_0_2);
};

template <bool del, class T, class Arg1, class Arg2>
class _ConstMemberResultCallback_0_2<del, void, T, Arg1, Arg2> : public Callback2<Arg1, Arg2> {
 public:
  typedef Callback2<Arg1, Arg2> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2) const;
  inline _ConstMemberResultCallback_0_2(const T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual void Run(Arg1 arg1, Arg2 arg2) {
    (object_->*member_)(arg1, arg2);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_0_2);
};

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _ConstMemberResultCallback_0_2<true, R, T1, Arg1, Arg2>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2) const) {
  return new _ConstMemberResultCallback_0_2<true, R, T1, Arg1, Arg2>(obj, member);
}

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _ConstMemberResultCallback_0_2<false, R, T1, Arg1, Arg2>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2) const) {
  return new _ConstMemberResultCallback_0_2<false, R, T1, Arg1, Arg2>(obj, member);
}

template <bool del, class R, class T, class Arg1, class Arg2>
class _MemberResultCallback_0_2 : public ResultCallback2<R, Arg1, Arg2> {
 public:
  typedef ResultCallback2<R, Arg1, Arg2> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2);
  inline _MemberResultCallback_0_2(T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual R Run(Arg1 arg1, Arg2 arg2) {
    R result = (object_->*member_)(arg1, arg2);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_0_2);
};

template <bool del, class T, class Arg1, class Arg2>
class _MemberResultCallback_0_2<del, void, T, Arg1, Arg2> : public Callback2<Arg1, Arg2> {
 public:
  typedef Callback2<Arg1, Arg2> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2);
  inline _MemberResultCallback_0_2(T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual void Run(Arg1 arg1, Arg2 arg2) {
    (object_->*member_)(arg1, arg2);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_0_2);
};

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _MemberResultCallback_0_2<true, R, T1, Arg1, Arg2>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2)) {
  return new _MemberResultCallback_0_2<true, R, T1, Arg1, Arg2>(obj, member);
}

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _MemberResultCallback_0_2<false, R, T1, Arg1, Arg2>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2)) {
  return new _MemberResultCallback_0_2<false, R, T1, Arg1, Arg2>(obj, member);
}

template <bool del, class R, class Arg1, class Arg2>
class _FunctionResultCallback_0_2 : public ResultCallback2<R, Arg1, Arg2> {
 public:
  typedef ResultCallback2<R, Arg1, Arg2> base;
  typedef R (*FunctionSignature)(Arg1, Arg2);
  inline _FunctionResultCallback_0_2(FunctionSignature function)
      : function_(function) {}

  virtual R Run(Arg1 arg1, Arg2 arg2) {
    R result = (*function_)(arg1, arg2);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_0_2);
};

template <bool del, class Arg1, class Arg2>
class _FunctionResultCallback_0_2<del, void, Arg1, Arg2> : public Callback2<Arg1, Arg2> {
 public:
  typedef Callback2<Arg1, Arg2> base;
  typedef void (*FunctionSignature)(Arg1, Arg2);
  inline _FunctionResultCallback_0_2(FunctionSignature function)
      : function_(function) {}

  virtual void Run(Arg1 arg1, Arg2 arg2) {
    (*function_)(arg1, arg2);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_0_2);
};

template <class R, class Arg1, class Arg2>
inline typename _FunctionResultCallback_0_2<true, R, Arg1, Arg2>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2)) {
  return new _FunctionResultCallback_0_2<true, R, Arg1, Arg2>(function);
}

template <class R, class Arg1, class Arg2>
inline typename _FunctionResultCallback_0_2<false, R, Arg1, Arg2>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2)) {
  return new _FunctionResultCallback_0_2<false, R, Arg1, Arg2>(function);
}

template <bool del, class R, class T, class Arg1, class Arg2>
class _ConstMemberResultCallback_1_2 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2) const;
  inline _ConstMemberResultCallback_1_2(const T* object, MemberSignature member, Arg2 arg2)
      : object_(object), member_(member), arg2_(arg2) {}

  virtual R Run(Arg1 arg1) {
    R result = (object_->*member_)(arg1, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_1_2);
};

template <bool del, class T, class Arg1, class Arg2>
class _ConstMemberResultCallback_1_2<del, void, T, Arg1, Arg2> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2) const;
  inline _ConstMemberResultCallback_1_2(const T* object, MemberSignature member, Arg2 arg2)
      : object_(object), member_(member), arg2_(arg2) {}

  virtual void Run(Arg1 arg1) {
    (object_->*member_)(arg1, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_1_2);
};

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _ConstMemberResultCallback_1_2<true, R, T1, Arg1, Arg2>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2) const, Arg2 arg2) {
  return new _ConstMemberResultCallback_1_2<true, R, T1, Arg1, Arg2>(obj, member, arg2);
}

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _ConstMemberResultCallback_1_2<false, R, T1, Arg1, Arg2>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2) const, Arg2 arg2) {
  return new _ConstMemberResultCallback_1_2<false, R, T1, Arg1, Arg2>(obj, member, arg2);
}

template <bool del, class R, class T, class Arg1, class Arg2>
class _MemberResultCallback_1_2 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2);
  inline _MemberResultCallback_1_2(T* object, MemberSignature member, Arg2 arg2)
      : object_(object), member_(member), arg2_(arg2) {}

  virtual R Run(Arg1 arg1) {
    R result = (object_->*member_)(arg1, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_1_2);
};

template <bool del, class T, class Arg1, class Arg2>
class _MemberResultCallback_1_2<del, void, T, Arg1, Arg2> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2);
  inline _MemberResultCallback_1_2(T* object, MemberSignature member, Arg2 arg2)
      : object_(object), member_(member), arg2_(arg2) {}

  virtual void Run(Arg1 arg1) {
    (object_->*member_)(arg1, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_1_2);
};

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _MemberResultCallback_1_2<true, R, T1, Arg1, Arg2>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2), Arg2 arg2) {
  return new _MemberResultCallback_1_2<true, R, T1, Arg1, Arg2>(obj, member, arg2);
}

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _MemberResultCallback_1_2<false, R, T1, Arg1, Arg2>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2), Arg2 arg2) {
  return new _MemberResultCallback_1_2<false, R, T1, Arg1, Arg2>(obj, member, arg2);
}

template <bool del, class R, class Arg1, class Arg2>
class _FunctionResultCallback_1_2 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (*FunctionSignature)(Arg1, Arg2);
  inline _FunctionResultCallback_1_2(FunctionSignature function, Arg2 arg2)
      : function_(function), arg2_(arg2) {}

  virtual R Run(Arg1 arg1) {
    R result = (*function_)(arg1, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_1_2);
};

template <bool del, class Arg1, class Arg2>
class _FunctionResultCallback_1_2<del, void, Arg1, Arg2> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (*FunctionSignature)(Arg1, Arg2);
  inline _FunctionResultCallback_1_2(FunctionSignature function, Arg2 arg2)
      : function_(function), arg2_(arg2) {}

  virtual void Run(Arg1 arg1) {
    (*function_)(arg1, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_1_2);
};

template <class R, class Arg1, class Arg2>
inline typename _FunctionResultCallback_1_2<true, R, Arg1, Arg2>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2), Arg2 arg2) {
  return new _FunctionResultCallback_1_2<true, R, Arg1, Arg2>(function, arg2);
}

template <class R, class Arg1, class Arg2>
inline typename _FunctionResultCallback_1_2<false, R, Arg1, Arg2>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2), Arg2 arg2) {
  return new _FunctionResultCallback_1_2<false, R, Arg1, Arg2>(function, arg2);
}

template <bool del, class R, class T, class Arg1, class Arg2>
class _ConstMemberResultCallback_2_2 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2) const;
  inline _ConstMemberResultCallback_2_2(const T* object, MemberSignature member, Arg1 arg1, Arg2 arg2)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2) {}

  virtual R Run() {
    R result = (object_->*member_)(arg1_, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_2_2);
};

template <bool del, class T, class Arg1, class Arg2>
class _ConstMemberResultCallback_2_2<del, void, T, Arg1, Arg2> : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)(Arg1, Arg2) const;
  inline _ConstMemberResultCallback_2_2(const T* object, MemberSignature member, Arg1 arg1, Arg2 arg2)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2) {}

  virtual void Run() {
    (object_->*member_)(arg1_, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_2_2);
};

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _ConstMemberResultCallback_2_2<true, R, T1, Arg1, Arg2>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2) const, Arg1 arg1, Arg2 arg2) {
  return new _ConstMemberResultCallback_2_2<true, R, T1, Arg1, Arg2>(obj, member, arg1, arg2);
}

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _ConstMemberResultCallback_2_2<false, R, T1, Arg1, Arg2>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2) const, Arg1 arg1, Arg2 arg2) {
  return new _ConstMemberResultCallback_2_2<false, R, T1, Arg1, Arg2>(obj, member, arg1, arg2);
}

template <bool del, class R, class T, class Arg1, class Arg2>
class _MemberResultCallback_2_2 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2);
  inline _MemberResultCallback_2_2(T* object, MemberSignature member, Arg1 arg1, Arg2 arg2)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2) {}

  virtual R Run() {
    R result = (object_->*member_)(arg1_, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_2_2);
};

template <bool del, class T, class Arg1, class Arg2>
class _MemberResultCallback_2_2<del, void, T, Arg1, Arg2> : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)(Arg1, Arg2);
  inline _MemberResultCallback_2_2(T* object, MemberSignature member, Arg1 arg1, Arg2 arg2)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2) {}

  virtual void Run() {
    (object_->*member_)(arg1_, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_2_2);
};

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _MemberResultCallback_2_2<true, R, T1, Arg1, Arg2>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2), Arg1 arg1, Arg2 arg2) {
  return new _MemberResultCallback_2_2<true, R, T1, Arg1, Arg2>(obj, member, arg1, arg2);
}

template <class T1, class T2, class R, class Arg1, class Arg2>
inline typename _MemberResultCallback_2_2<false, R, T1, Arg1, Arg2>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2), Arg1 arg1, Arg2 arg2) {
  return new _MemberResultCallback_2_2<false, R, T1, Arg1, Arg2>(obj, member, arg1, arg2);
}

template <bool del, class R, class Arg1, class Arg2>
class _FunctionResultCallback_2_2 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (*FunctionSignature)(Arg1, Arg2);
  inline _FunctionResultCallback_2_2(FunctionSignature function, Arg1 arg1, Arg2 arg2)
      : function_(function), arg1_(arg1), arg2_(arg2) {}

  virtual R Run() {
    R result = (*function_)(arg1_, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  Arg1 arg1_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_2_2);
};

template <bool del, class Arg1, class Arg2>
class _FunctionResultCallback_2_2<del, void, Arg1, Arg2> : public Closure {
 public:
  typedef Closure base;
  typedef void (*FunctionSignature)(Arg1, Arg2);
  inline _FunctionResultCallback_2_2(FunctionSignature function, Arg1 arg1, Arg2 arg2)
      : function_(function), arg1_(arg1), arg2_(arg2) {}

  virtual void Run() {
    (*function_)(arg1_, arg2_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  Arg1 arg1_;
  Arg2 arg2_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_2_2);
};

template <class R, class Arg1, class Arg2>
inline typename _FunctionResultCallback_2_2<true, R, Arg1, Arg2>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2), Arg1 arg1, Arg2 arg2) {
  return new _FunctionResultCallback_2_2<true, R, Arg1, Arg2>(function, arg1, arg2);
}

template <class R, class Arg1, class Arg2>
inline typename _FunctionResultCallback_2_2<false, R, Arg1, Arg2>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2), Arg1 arg1, Arg2 arg2) {
  return new _FunctionResultCallback_2_2<false, R, Arg1, Arg2>(function, arg1, arg2);
}

template <class Arg1, class Arg2, class Arg3>
class Callback3 {
 public:
  Callback3() {}
  virtual ~Callback3() {}
  virtual void Run(Arg1, Arg2, Arg3) = 0;
 private:
  DISALLOW_COPY_AND_ASSIGN(Callback3);
};

template <class R, class Arg1, class Arg2, class Arg3>
class ResultCallback3 {
 public:
  ResultCallback3() {}
  virtual ~ResultCallback3() {}
  virtual R Run(Arg1, Arg2, Arg3) = 0;
 private:
  DISALLOW_COPY_AND_ASSIGN(ResultCallback3);
};

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3>
class _ConstMemberResultCallback_0_3 : public ResultCallback3<R, Arg1, Arg2, Arg3> {
 public:
  typedef ResultCallback3<R, Arg1, Arg2, Arg3> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3) const;
  inline _ConstMemberResultCallback_0_3(const T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    R result = (object_->*member_)(arg1, arg2, arg3);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_0_3);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3>
class _ConstMemberResultCallback_0_3<del, void, T, Arg1, Arg2, Arg3> : public Callback3<Arg1, Arg2, Arg3> {
 public:
  typedef Callback3<Arg1, Arg2, Arg3> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3) const;
  inline _ConstMemberResultCallback_0_3(const T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual void Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    (object_->*member_)(arg1, arg2, arg3);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_0_3);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _ConstMemberResultCallback_0_3<true, R, T1, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3) const) {
  return new _ConstMemberResultCallback_0_3<true, R, T1, Arg1, Arg2, Arg3>(obj, member);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _ConstMemberResultCallback_0_3<false, R, T1, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3) const) {
  return new _ConstMemberResultCallback_0_3<false, R, T1, Arg1, Arg2, Arg3>(obj, member);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3>
class _MemberResultCallback_0_3 : public ResultCallback3<R, Arg1, Arg2, Arg3> {
 public:
  typedef ResultCallback3<R, Arg1, Arg2, Arg3> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3);
  inline _MemberResultCallback_0_3(T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    R result = (object_->*member_)(arg1, arg2, arg3);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_0_3);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3>
class _MemberResultCallback_0_3<del, void, T, Arg1, Arg2, Arg3> : public Callback3<Arg1, Arg2, Arg3> {
 public:
  typedef Callback3<Arg1, Arg2, Arg3> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3);
  inline _MemberResultCallback_0_3(T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual void Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    (object_->*member_)(arg1, arg2, arg3);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_0_3);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _MemberResultCallback_0_3<true, R, T1, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3)) {
  return new _MemberResultCallback_0_3<true, R, T1, Arg1, Arg2, Arg3>(obj, member);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _MemberResultCallback_0_3<false, R, T1, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3)) {
  return new _MemberResultCallback_0_3<false, R, T1, Arg1, Arg2, Arg3>(obj, member);
}

template <bool del, class R, class Arg1, class Arg2, class Arg3>
class _FunctionResultCallback_0_3 : public ResultCallback3<R, Arg1, Arg2, Arg3> {
 public:
  typedef ResultCallback3<R, Arg1, Arg2, Arg3> base;
  typedef R (*FunctionSignature)(Arg1, Arg2, Arg3);
  inline _FunctionResultCallback_0_3(FunctionSignature function)
      : function_(function) {}

  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    R result = (*function_)(arg1, arg2, arg3);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_0_3);
};

template <bool del, class Arg1, class Arg2, class Arg3>
class _FunctionResultCallback_0_3<del, void, Arg1, Arg2, Arg3> : public Callback3<Arg1, Arg2, Arg3> {
 public:
  typedef Callback3<Arg1, Arg2, Arg3> base;
  typedef void (*FunctionSignature)(Arg1, Arg2, Arg3);
  inline _FunctionResultCallback_0_3(FunctionSignature function)
      : function_(function) {}

  virtual void Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    (*function_)(arg1, arg2, arg3);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_0_3);
};

template <class R, class Arg1, class Arg2, class Arg3>
inline typename _FunctionResultCallback_0_3<true, R, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2, Arg3)) {
  return new _FunctionResultCallback_0_3<true, R, Arg1, Arg2, Arg3>(function);
}

template <class R, class Arg1, class Arg2, class Arg3>
inline typename _FunctionResultCallback_0_3<false, R, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2, Arg3)) {
  return new _FunctionResultCallback_0_3<false, R, Arg1, Arg2, Arg3>(function);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3>
class _ConstMemberResultCallback_1_3 : public ResultCallback2<R, Arg1, Arg2> {
 public:
  typedef ResultCallback2<R, Arg1, Arg2> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3) const;
  inline _ConstMemberResultCallback_1_3(const T* object, MemberSignature member, Arg3 arg3)
      : object_(object), member_(member), arg3_(arg3) {}

  virtual R Run(Arg1 arg1, Arg2 arg2) {
    R result = (object_->*member_)(arg1, arg2, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_1_3);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3>
class _ConstMemberResultCallback_1_3<del, void, T, Arg1, Arg2, Arg3> : public Callback2<Arg1, Arg2> {
 public:
  typedef Callback2<Arg1, Arg2> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3) const;
  inline _ConstMemberResultCallback_1_3(const T* object, MemberSignature member, Arg3 arg3)
      : object_(object), member_(member), arg3_(arg3) {}

  virtual void Run(Arg1 arg1, Arg2 arg2) {
    (object_->*member_)(arg1, arg2, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_1_3);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _ConstMemberResultCallback_1_3<true, R, T1, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3) const, Arg3 arg3) {
  return new _ConstMemberResultCallback_1_3<true, R, T1, Arg1, Arg2, Arg3>(obj, member, arg3);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _ConstMemberResultCallback_1_3<false, R, T1, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3) const, Arg3 arg3) {
  return new _ConstMemberResultCallback_1_3<false, R, T1, Arg1, Arg2, Arg3>(obj, member, arg3);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3>
class _MemberResultCallback_1_3 : public ResultCallback2<R, Arg1, Arg2> {
 public:
  typedef ResultCallback2<R, Arg1, Arg2> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3);
  inline _MemberResultCallback_1_3(T* object, MemberSignature member, Arg3 arg3)
      : object_(object), member_(member), arg3_(arg3) {}

  virtual R Run(Arg1 arg1, Arg2 arg2) {
    R result = (object_->*member_)(arg1, arg2, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_1_3);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3>
class _MemberResultCallback_1_3<del, void, T, Arg1, Arg2, Arg3> : public Callback2<Arg1, Arg2> {
 public:
  typedef Callback2<Arg1, Arg2> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3);
  inline _MemberResultCallback_1_3(T* object, MemberSignature member, Arg3 arg3)
      : object_(object), member_(member), arg3_(arg3) {}

  virtual void Run(Arg1 arg1, Arg2 arg2) {
    (object_->*member_)(arg1, arg2, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_1_3);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _MemberResultCallback_1_3<true, R, T1, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3), Arg3 arg3) {
  return new _MemberResultCallback_1_3<true, R, T1, Arg1, Arg2, Arg3>(obj, member, arg3);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _MemberResultCallback_1_3<false, R, T1, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3), Arg3 arg3) {
  return new _MemberResultCallback_1_3<false, R, T1, Arg1, Arg2, Arg3>(obj, member, arg3);
}

template <bool del, class R, class Arg1, class Arg2, class Arg3>
class _FunctionResultCallback_1_3 : public ResultCallback2<R, Arg1, Arg2> {
 public:
  typedef ResultCallback2<R, Arg1, Arg2> base;
  typedef R (*FunctionSignature)(Arg1, Arg2, Arg3);
  inline _FunctionResultCallback_1_3(FunctionSignature function, Arg3 arg3)
      : function_(function), arg3_(arg3) {}

  virtual R Run(Arg1 arg1, Arg2 arg2) {
    R result = (*function_)(arg1, arg2, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_1_3);
};

template <bool del, class Arg1, class Arg2, class Arg3>
class _FunctionResultCallback_1_3<del, void, Arg1, Arg2, Arg3> : public Callback2<Arg1, Arg2> {
 public:
  typedef Callback2<Arg1, Arg2> base;
  typedef void (*FunctionSignature)(Arg1, Arg2, Arg3);
  inline _FunctionResultCallback_1_3(FunctionSignature function, Arg3 arg3)
      : function_(function), arg3_(arg3) {}

  virtual void Run(Arg1 arg1, Arg2 arg2) {
    (*function_)(arg1, arg2, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_1_3);
};

template <class R, class Arg1, class Arg2, class Arg3>
inline typename _FunctionResultCallback_1_3<true, R, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2, Arg3), Arg3 arg3) {
  return new _FunctionResultCallback_1_3<true, R, Arg1, Arg2, Arg3>(function, arg3);
}

template <class R, class Arg1, class Arg2, class Arg3>
inline typename _FunctionResultCallback_1_3<false, R, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2, Arg3), Arg3 arg3) {
  return new _FunctionResultCallback_1_3<false, R, Arg1, Arg2, Arg3>(function, arg3);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3>
class _ConstMemberResultCallback_2_3 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3) const;
  inline _ConstMemberResultCallback_2_3(const T* object, MemberSignature member, Arg2 arg2, Arg3 arg3)
      : object_(object), member_(member), arg2_(arg2), arg3_(arg3) {}

  virtual R Run(Arg1 arg1) {
    R result = (object_->*member_)(arg1, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_2_3);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3>
class _ConstMemberResultCallback_2_3<del, void, T, Arg1, Arg2, Arg3> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3) const;
  inline _ConstMemberResultCallback_2_3(const T* object, MemberSignature member, Arg2 arg2, Arg3 arg3)
      : object_(object), member_(member), arg2_(arg2), arg3_(arg3) {}

  virtual void Run(Arg1 arg1) {
    (object_->*member_)(arg1, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_2_3);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _ConstMemberResultCallback_2_3<true, R, T1, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3) const, Arg2 arg2, Arg3 arg3) {
  return new _ConstMemberResultCallback_2_3<true, R, T1, Arg1, Arg2, Arg3>(obj, member, arg2, arg3);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _ConstMemberResultCallback_2_3<false, R, T1, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3) const, Arg2 arg2, Arg3 arg3) {
  return new _ConstMemberResultCallback_2_3<false, R, T1, Arg1, Arg2, Arg3>(obj, member, arg2, arg3);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3>
class _MemberResultCallback_2_3 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3);
  inline _MemberResultCallback_2_3(T* object, MemberSignature member, Arg2 arg2, Arg3 arg3)
      : object_(object), member_(member), arg2_(arg2), arg3_(arg3) {}

  virtual R Run(Arg1 arg1) {
    R result = (object_->*member_)(arg1, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_2_3);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3>
class _MemberResultCallback_2_3<del, void, T, Arg1, Arg2, Arg3> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3);
  inline _MemberResultCallback_2_3(T* object, MemberSignature member, Arg2 arg2, Arg3 arg3)
      : object_(object), member_(member), arg2_(arg2), arg3_(arg3) {}

  virtual void Run(Arg1 arg1) {
    (object_->*member_)(arg1, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_2_3);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _MemberResultCallback_2_3<true, R, T1, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3), Arg2 arg2, Arg3 arg3) {
  return new _MemberResultCallback_2_3<true, R, T1, Arg1, Arg2, Arg3>(obj, member, arg2, arg3);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _MemberResultCallback_2_3<false, R, T1, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3), Arg2 arg2, Arg3 arg3) {
  return new _MemberResultCallback_2_3<false, R, T1, Arg1, Arg2, Arg3>(obj, member, arg2, arg3);
}

template <bool del, class R, class Arg1, class Arg2, class Arg3>
class _FunctionResultCallback_2_3 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (*FunctionSignature)(Arg1, Arg2, Arg3);
  inline _FunctionResultCallback_2_3(FunctionSignature function, Arg2 arg2, Arg3 arg3)
      : function_(function), arg2_(arg2), arg3_(arg3) {}

  virtual R Run(Arg1 arg1) {
    R result = (*function_)(arg1, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_2_3);
};

template <bool del, class Arg1, class Arg2, class Arg3>
class _FunctionResultCallback_2_3<del, void, Arg1, Arg2, Arg3> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (*FunctionSignature)(Arg1, Arg2, Arg3);
  inline _FunctionResultCallback_2_3(FunctionSignature function, Arg2 arg2, Arg3 arg3)
      : function_(function), arg2_(arg2), arg3_(arg3) {}

  virtual void Run(Arg1 arg1) {
    (*function_)(arg1, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_2_3);
};

template <class R, class Arg1, class Arg2, class Arg3>
inline typename _FunctionResultCallback_2_3<true, R, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2, Arg3), Arg2 arg2, Arg3 arg3) {
  return new _FunctionResultCallback_2_3<true, R, Arg1, Arg2, Arg3>(function, arg2, arg3);
}

template <class R, class Arg1, class Arg2, class Arg3>
inline typename _FunctionResultCallback_2_3<false, R, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2, Arg3), Arg2 arg2, Arg3 arg3) {
  return new _FunctionResultCallback_2_3<false, R, Arg1, Arg2, Arg3>(function, arg2, arg3);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3>
class _ConstMemberResultCallback_3_3 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3) const;
  inline _ConstMemberResultCallback_3_3(const T* object, MemberSignature member, Arg1 arg1, Arg2 arg2, Arg3 arg3)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2), arg3_(arg3) {}

  virtual R Run() {
    R result = (object_->*member_)(arg1_, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_3_3);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3>
class _ConstMemberResultCallback_3_3<del, void, T, Arg1, Arg2, Arg3> : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3) const;
  inline _ConstMemberResultCallback_3_3(const T* object, MemberSignature member, Arg1 arg1, Arg2 arg2, Arg3 arg3)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2), arg3_(arg3) {}

  virtual void Run() {
    (object_->*member_)(arg1_, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_3_3);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _ConstMemberResultCallback_3_3<true, R, T1, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3) const, Arg1 arg1, Arg2 arg2, Arg3 arg3) {
  return new _ConstMemberResultCallback_3_3<true, R, T1, Arg1, Arg2, Arg3>(obj, member, arg1, arg2, arg3);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _ConstMemberResultCallback_3_3<false, R, T1, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3) const, Arg1 arg1, Arg2 arg2, Arg3 arg3) {
  return new _ConstMemberResultCallback_3_3<false, R, T1, Arg1, Arg2, Arg3>(obj, member, arg1, arg2, arg3);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3>
class _MemberResultCallback_3_3 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3);
  inline _MemberResultCallback_3_3(T* object, MemberSignature member, Arg1 arg1, Arg2 arg2, Arg3 arg3)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2), arg3_(arg3) {}

  virtual R Run() {
    R result = (object_->*member_)(arg1_, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_3_3);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3>
class _MemberResultCallback_3_3<del, void, T, Arg1, Arg2, Arg3> : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3);
  inline _MemberResultCallback_3_3(T* object, MemberSignature member, Arg1 arg1, Arg2 arg2, Arg3 arg3)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2), arg3_(arg3) {}

  virtual void Run() {
    (object_->*member_)(arg1_, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_3_3);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _MemberResultCallback_3_3<true, R, T1, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3), Arg1 arg1, Arg2 arg2, Arg3 arg3) {
  return new _MemberResultCallback_3_3<true, R, T1, Arg1, Arg2, Arg3>(obj, member, arg1, arg2, arg3);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3>
inline typename _MemberResultCallback_3_3<false, R, T1, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3), Arg1 arg1, Arg2 arg2, Arg3 arg3) {
  return new _MemberResultCallback_3_3<false, R, T1, Arg1, Arg2, Arg3>(obj, member, arg1, arg2, arg3);
}

template <bool del, class R, class Arg1, class Arg2, class Arg3>
class _FunctionResultCallback_3_3 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (*FunctionSignature)(Arg1, Arg2, Arg3);
  inline _FunctionResultCallback_3_3(FunctionSignature function, Arg1 arg1, Arg2 arg2, Arg3 arg3)
      : function_(function), arg1_(arg1), arg2_(arg2), arg3_(arg3) {}

  virtual R Run() {
    R result = (*function_)(arg1_, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_3_3);
};

template <bool del, class Arg1, class Arg2, class Arg3>
class _FunctionResultCallback_3_3<del, void, Arg1, Arg2, Arg3> : public Closure {
 public:
  typedef Closure base;
  typedef void (*FunctionSignature)(Arg1, Arg2, Arg3);
  inline _FunctionResultCallback_3_3(FunctionSignature function, Arg1 arg1, Arg2 arg2, Arg3 arg3)
      : function_(function), arg1_(arg1), arg2_(arg2), arg3_(arg3) {}

  virtual void Run() {
    (*function_)(arg1_, arg2_, arg3_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_3_3);
};

template <class R, class Arg1, class Arg2, class Arg3>
inline typename _FunctionResultCallback_3_3<true, R, Arg1, Arg2, Arg3>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2, Arg3), Arg1 arg1, Arg2 arg2, Arg3 arg3) {
  return new _FunctionResultCallback_3_3<true, R, Arg1, Arg2, Arg3>(function, arg1, arg2, arg3);
}

template <class R, class Arg1, class Arg2, class Arg3>
inline typename _FunctionResultCallback_3_3<false, R, Arg1, Arg2, Arg3>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2, Arg3), Arg1 arg1, Arg2 arg2, Arg3 arg3) {
  return new _FunctionResultCallback_3_3<false, R, Arg1, Arg2, Arg3>(function, arg1, arg2, arg3);
}

template <class Arg1, class Arg2, class Arg3, class Arg4>
class Callback4 {
 public:
  Callback4() {}
  virtual ~Callback4() {}
  virtual void Run(Arg1, Arg2, Arg3, Arg4) = 0;
 private:
  DISALLOW_COPY_AND_ASSIGN(Callback4);
};

template <class R, class Arg1, class Arg2, class Arg3, class Arg4>
class ResultCallback4 {
 public:
  ResultCallback4() {}
  virtual ~ResultCallback4() {}
  virtual R Run(Arg1, Arg2, Arg3, Arg4) = 0;
 private:
  DISALLOW_COPY_AND_ASSIGN(ResultCallback4);
};

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _ConstMemberResultCallback_0_4 : public ResultCallback4<R, Arg1, Arg2, Arg3, Arg4> {
 public:
  typedef ResultCallback4<R, Arg1, Arg2, Arg3, Arg4> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4) const;
  inline _ConstMemberResultCallback_0_4(const T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    R result = (object_->*member_)(arg1, arg2, arg3, arg4);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_0_4);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _ConstMemberResultCallback_0_4<del, void, T, Arg1, Arg2, Arg3, Arg4> : public Callback4<Arg1, Arg2, Arg3, Arg4> {
 public:
  typedef Callback4<Arg1, Arg2, Arg3, Arg4> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4) const;
  inline _ConstMemberResultCallback_0_4(const T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual void Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    (object_->*member_)(arg1, arg2, arg3, arg4);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_0_4);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _ConstMemberResultCallback_0_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4) const) {
  return new _ConstMemberResultCallback_0_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _ConstMemberResultCallback_0_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4) const) {
  return new _ConstMemberResultCallback_0_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _MemberResultCallback_0_4 : public ResultCallback4<R, Arg1, Arg2, Arg3, Arg4> {
 public:
  typedef ResultCallback4<R, Arg1, Arg2, Arg3, Arg4> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _MemberResultCallback_0_4(T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    R result = (object_->*member_)(arg1, arg2, arg3, arg4);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_0_4);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _MemberResultCallback_0_4<del, void, T, Arg1, Arg2, Arg3, Arg4> : public Callback4<Arg1, Arg2, Arg3, Arg4> {
 public:
  typedef Callback4<Arg1, Arg2, Arg3, Arg4> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _MemberResultCallback_0_4(T* object, MemberSignature member)
      : object_(object), member_(member) {}

  virtual void Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    (object_->*member_)(arg1, arg2, arg3, arg4);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_0_4);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _MemberResultCallback_0_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4)) {
  return new _MemberResultCallback_0_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _MemberResultCallback_0_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4)) {
  return new _MemberResultCallback_0_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member);
}

template <bool del, class R, class Arg1, class Arg2, class Arg3, class Arg4>
class _FunctionResultCallback_0_4 : public ResultCallback4<R, Arg1, Arg2, Arg3, Arg4> {
 public:
  typedef ResultCallback4<R, Arg1, Arg2, Arg3, Arg4> base;
  typedef R (*FunctionSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _FunctionResultCallback_0_4(FunctionSignature function)
      : function_(function) {}

  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    R result = (*function_)(arg1, arg2, arg3, arg4);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_0_4);
};

template <bool del, class Arg1, class Arg2, class Arg3, class Arg4>
class _FunctionResultCallback_0_4<del, void, Arg1, Arg2, Arg3, Arg4> : public Callback4<Arg1, Arg2, Arg3, Arg4> {
 public:
  typedef Callback4<Arg1, Arg2, Arg3, Arg4> base;
  typedef void (*FunctionSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _FunctionResultCallback_0_4(FunctionSignature function)
      : function_(function) {}

  virtual void Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    (*function_)(arg1, arg2, arg3, arg4);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_0_4);
};

template <class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _FunctionResultCallback_0_4<true, R, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2, Arg3, Arg4)) {
  return new _FunctionResultCallback_0_4<true, R, Arg1, Arg2, Arg3, Arg4>(function);
}

template <class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _FunctionResultCallback_0_4<false, R, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2, Arg3, Arg4)) {
  return new _FunctionResultCallback_0_4<false, R, Arg1, Arg2, Arg3, Arg4>(function);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _ConstMemberResultCallback_1_4 : public ResultCallback3<R, Arg1, Arg2, Arg3> {
 public:
  typedef ResultCallback3<R, Arg1, Arg2, Arg3> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4) const;
  inline _ConstMemberResultCallback_1_4(const T* object, MemberSignature member, Arg4 arg4)
      : object_(object), member_(member), arg4_(arg4) {}

  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    R result = (object_->*member_)(arg1, arg2, arg3, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_1_4);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _ConstMemberResultCallback_1_4<del, void, T, Arg1, Arg2, Arg3, Arg4> : public Callback3<Arg1, Arg2, Arg3> {
 public:
  typedef Callback3<Arg1, Arg2, Arg3> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4) const;
  inline _ConstMemberResultCallback_1_4(const T* object, MemberSignature member, Arg4 arg4)
      : object_(object), member_(member), arg4_(arg4) {}

  virtual void Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    (object_->*member_)(arg1, arg2, arg3, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_1_4);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _ConstMemberResultCallback_1_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4) const, Arg4 arg4) {
  return new _ConstMemberResultCallback_1_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg4);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _ConstMemberResultCallback_1_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4) const, Arg4 arg4) {
  return new _ConstMemberResultCallback_1_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg4);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _MemberResultCallback_1_4 : public ResultCallback3<R, Arg1, Arg2, Arg3> {
 public:
  typedef ResultCallback3<R, Arg1, Arg2, Arg3> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _MemberResultCallback_1_4(T* object, MemberSignature member, Arg4 arg4)
      : object_(object), member_(member), arg4_(arg4) {}

  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    R result = (object_->*member_)(arg1, arg2, arg3, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_1_4);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _MemberResultCallback_1_4<del, void, T, Arg1, Arg2, Arg3, Arg4> : public Callback3<Arg1, Arg2, Arg3> {
 public:
  typedef Callback3<Arg1, Arg2, Arg3> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _MemberResultCallback_1_4(T* object, MemberSignature member, Arg4 arg4)
      : object_(object), member_(member), arg4_(arg4) {}

  virtual void Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    (object_->*member_)(arg1, arg2, arg3, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_1_4);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _MemberResultCallback_1_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4), Arg4 arg4) {
  return new _MemberResultCallback_1_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg4);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _MemberResultCallback_1_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4), Arg4 arg4) {
  return new _MemberResultCallback_1_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg4);
}

template <bool del, class R, class Arg1, class Arg2, class Arg3, class Arg4>
class _FunctionResultCallback_1_4 : public ResultCallback3<R, Arg1, Arg2, Arg3> {
 public:
  typedef ResultCallback3<R, Arg1, Arg2, Arg3> base;
  typedef R (*FunctionSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _FunctionResultCallback_1_4(FunctionSignature function, Arg4 arg4)
      : function_(function), arg4_(arg4) {}

  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    R result = (*function_)(arg1, arg2, arg3, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_1_4);
};

template <bool del, class Arg1, class Arg2, class Arg3, class Arg4>
class _FunctionResultCallback_1_4<del, void, Arg1, Arg2, Arg3, Arg4> : public Callback3<Arg1, Arg2, Arg3> {
 public:
  typedef Callback3<Arg1, Arg2, Arg3> base;
  typedef void (*FunctionSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _FunctionResultCallback_1_4(FunctionSignature function, Arg4 arg4)
      : function_(function), arg4_(arg4) {}

  virtual void Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    (*function_)(arg1, arg2, arg3, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_1_4);
};

template <class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _FunctionResultCallback_1_4<true, R, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2, Arg3, Arg4), Arg4 arg4) {
  return new _FunctionResultCallback_1_4<true, R, Arg1, Arg2, Arg3, Arg4>(function, arg4);
}

template <class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _FunctionResultCallback_1_4<false, R, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2, Arg3, Arg4), Arg4 arg4) {
  return new _FunctionResultCallback_1_4<false, R, Arg1, Arg2, Arg3, Arg4>(function, arg4);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _ConstMemberResultCallback_2_4 : public ResultCallback2<R, Arg1, Arg2> {
 public:
  typedef ResultCallback2<R, Arg1, Arg2> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4) const;
  inline _ConstMemberResultCallback_2_4(const T* object, MemberSignature member, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg3_(arg3), arg4_(arg4) {}

  virtual R Run(Arg1 arg1, Arg2 arg2) {
    R result = (object_->*member_)(arg1, arg2, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_2_4);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _ConstMemberResultCallback_2_4<del, void, T, Arg1, Arg2, Arg3, Arg4> : public Callback2<Arg1, Arg2> {
 public:
  typedef Callback2<Arg1, Arg2> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4) const;
  inline _ConstMemberResultCallback_2_4(const T* object, MemberSignature member, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg3_(arg3), arg4_(arg4) {}

  virtual void Run(Arg1 arg1, Arg2 arg2) {
    (object_->*member_)(arg1, arg2, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_2_4);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _ConstMemberResultCallback_2_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4) const, Arg3 arg3, Arg4 arg4) {
  return new _ConstMemberResultCallback_2_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg3, arg4);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _ConstMemberResultCallback_2_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4) const, Arg3 arg3, Arg4 arg4) {
  return new _ConstMemberResultCallback_2_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg3, arg4);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _MemberResultCallback_2_4 : public ResultCallback2<R, Arg1, Arg2> {
 public:
  typedef ResultCallback2<R, Arg1, Arg2> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _MemberResultCallback_2_4(T* object, MemberSignature member, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg3_(arg3), arg4_(arg4) {}

  virtual R Run(Arg1 arg1, Arg2 arg2) {
    R result = (object_->*member_)(arg1, arg2, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_2_4);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _MemberResultCallback_2_4<del, void, T, Arg1, Arg2, Arg3, Arg4> : public Callback2<Arg1, Arg2> {
 public:
  typedef Callback2<Arg1, Arg2> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _MemberResultCallback_2_4(T* object, MemberSignature member, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg3_(arg3), arg4_(arg4) {}

  virtual void Run(Arg1 arg1, Arg2 arg2) {
    (object_->*member_)(arg1, arg2, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_2_4);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _MemberResultCallback_2_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4), Arg3 arg3, Arg4 arg4) {
  return new _MemberResultCallback_2_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg3, arg4);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _MemberResultCallback_2_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4), Arg3 arg3, Arg4 arg4) {
  return new _MemberResultCallback_2_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg3, arg4);
}

template <bool del, class R, class Arg1, class Arg2, class Arg3, class Arg4>
class _FunctionResultCallback_2_4 : public ResultCallback2<R, Arg1, Arg2> {
 public:
  typedef ResultCallback2<R, Arg1, Arg2> base;
  typedef R (*FunctionSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _FunctionResultCallback_2_4(FunctionSignature function, Arg3 arg3, Arg4 arg4)
      : function_(function), arg3_(arg3), arg4_(arg4) {}

  virtual R Run(Arg1 arg1, Arg2 arg2) {
    R result = (*function_)(arg1, arg2, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_2_4);
};

template <bool del, class Arg1, class Arg2, class Arg3, class Arg4>
class _FunctionResultCallback_2_4<del, void, Arg1, Arg2, Arg3, Arg4> : public Callback2<Arg1, Arg2> {
 public:
  typedef Callback2<Arg1, Arg2> base;
  typedef void (*FunctionSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _FunctionResultCallback_2_4(FunctionSignature function, Arg3 arg3, Arg4 arg4)
      : function_(function), arg3_(arg3), arg4_(arg4) {}

  virtual void Run(Arg1 arg1, Arg2 arg2) {
    (*function_)(arg1, arg2, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_2_4);
};

template <class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _FunctionResultCallback_2_4<true, R, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2, Arg3, Arg4), Arg3 arg3, Arg4 arg4) {
  return new _FunctionResultCallback_2_4<true, R, Arg1, Arg2, Arg3, Arg4>(function, arg3, arg4);
}

template <class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _FunctionResultCallback_2_4<false, R, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2, Arg3, Arg4), Arg3 arg3, Arg4 arg4) {
  return new _FunctionResultCallback_2_4<false, R, Arg1, Arg2, Arg3, Arg4>(function, arg3, arg4);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _ConstMemberResultCallback_3_4 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4) const;
  inline _ConstMemberResultCallback_3_4(const T* object, MemberSignature member, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual R Run(Arg1 arg1) {
    R result = (object_->*member_)(arg1, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_3_4);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _ConstMemberResultCallback_3_4<del, void, T, Arg1, Arg2, Arg3, Arg4> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4) const;
  inline _ConstMemberResultCallback_3_4(const T* object, MemberSignature member, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual void Run(Arg1 arg1) {
    (object_->*member_)(arg1, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_3_4);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _ConstMemberResultCallback_3_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4) const, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _ConstMemberResultCallback_3_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg2, arg3, arg4);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _ConstMemberResultCallback_3_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4) const, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _ConstMemberResultCallback_3_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg2, arg3, arg4);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _MemberResultCallback_3_4 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _MemberResultCallback_3_4(T* object, MemberSignature member, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual R Run(Arg1 arg1) {
    R result = (object_->*member_)(arg1, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_3_4);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _MemberResultCallback_3_4<del, void, T, Arg1, Arg2, Arg3, Arg4> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _MemberResultCallback_3_4(T* object, MemberSignature member, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual void Run(Arg1 arg1) {
    (object_->*member_)(arg1, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_3_4);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _MemberResultCallback_3_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4), Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _MemberResultCallback_3_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg2, arg3, arg4);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _MemberResultCallback_3_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4), Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _MemberResultCallback_3_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg2, arg3, arg4);
}

template <bool del, class R, class Arg1, class Arg2, class Arg3, class Arg4>
class _FunctionResultCallback_3_4 : public ResultCallback1<R, Arg1> {
 public:
  typedef ResultCallback1<R, Arg1> base;
  typedef R (*FunctionSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _FunctionResultCallback_3_4(FunctionSignature function, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : function_(function), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual R Run(Arg1 arg1) {
    R result = (*function_)(arg1, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_3_4);
};

template <bool del, class Arg1, class Arg2, class Arg3, class Arg4>
class _FunctionResultCallback_3_4<del, void, Arg1, Arg2, Arg3, Arg4> : public Callback1<Arg1> {
 public:
  typedef Callback1<Arg1> base;
  typedef void (*FunctionSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _FunctionResultCallback_3_4(FunctionSignature function, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : function_(function), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual void Run(Arg1 arg1) {
    (*function_)(arg1, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_3_4);
};

template <class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _FunctionResultCallback_3_4<true, R, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2, Arg3, Arg4), Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _FunctionResultCallback_3_4<true, R, Arg1, Arg2, Arg3, Arg4>(function, arg2, arg3, arg4);
}

template <class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _FunctionResultCallback_3_4<false, R, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2, Arg3, Arg4), Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _FunctionResultCallback_3_4<false, R, Arg1, Arg2, Arg3, Arg4>(function, arg2, arg3, arg4);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _ConstMemberResultCallback_4_4 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4) const;
  inline _ConstMemberResultCallback_4_4(const T* object, MemberSignature member, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual R Run() {
    R result = (object_->*member_)(arg1_, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_4_4);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _ConstMemberResultCallback_4_4<del, void, T, Arg1, Arg2, Arg3, Arg4> : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4) const;
  inline _ConstMemberResultCallback_4_4(const T* object, MemberSignature member, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual void Run() {
    (object_->*member_)(arg1_, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  const T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_ConstMemberResultCallback_4_4);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _ConstMemberResultCallback_4_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4) const, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _ConstMemberResultCallback_4_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg1, arg2, arg3, arg4);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _ConstMemberResultCallback_4_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(const T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4) const, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _ConstMemberResultCallback_4_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg1, arg2, arg3, arg4);
}

template <bool del, class R, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _MemberResultCallback_4_4 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _MemberResultCallback_4_4(T* object, MemberSignature member, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual R Run() {
    R result = (object_->*member_)(arg1_, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_4_4);
};

template <bool del, class T, class Arg1, class Arg2, class Arg3, class Arg4>
class _MemberResultCallback_4_4<del, void, T, Arg1, Arg2, Arg3, Arg4> : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _MemberResultCallback_4_4(T* object, MemberSignature member, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : object_(object), member_(member), arg1_(arg1), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual void Run() {
    (object_->*member_)(arg1_, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
 private:
  T* object_;
  MemberSignature member_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_MemberResultCallback_4_4);
};

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _MemberResultCallback_4_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4), Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _MemberResultCallback_4_4<true, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg1, arg2, arg3, arg4);
}

template <class T1, class T2, class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _MemberResultCallback_4_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(T1* obj, R (T2::*member)(Arg1, Arg2, Arg3, Arg4), Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _MemberResultCallback_4_4<false, R, T1, Arg1, Arg2, Arg3, Arg4>(obj, member, arg1, arg2, arg3, arg4);
}

template <bool del, class R, class Arg1, class Arg2, class Arg3, class Arg4>
class _FunctionResultCallback_4_4 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (*FunctionSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _FunctionResultCallback_4_4(FunctionSignature function, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : function_(function), arg1_(arg1), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual R Run() {
    R result = (*function_)(arg1_, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
    return result;
  }
 private:
  FunctionSignature function_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_4_4);
};

template <bool del, class Arg1, class Arg2, class Arg3, class Arg4>
class _FunctionResultCallback_4_4<del, void, Arg1, Arg2, Arg3, Arg4> : public Closure {
 public:
  typedef Closure base;
  typedef void (*FunctionSignature)(Arg1, Arg2, Arg3, Arg4);
  inline _FunctionResultCallback_4_4(FunctionSignature function, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
      : function_(function), arg1_(arg1), arg2_(arg2), arg3_(arg3), arg4_(arg4) {}

  virtual void Run() {
    (*function_)(arg1_, arg2_, arg3_, arg4_);
    if (del) {
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
 private:
  FunctionSignature function_;
  Arg1 arg1_;
  Arg2 arg2_;
  Arg3 arg3_;
  Arg4 arg4_;

  DISALLOW_COPY_AND_ASSIGN(_FunctionResultCallback_4_4);
};

template <class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _FunctionResultCallback_4_4<true, R, Arg1, Arg2, Arg3, Arg4>::base*
NewOneTimeCallback(R (*function)(Arg1, Arg2, Arg3, Arg4), Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _FunctionResultCallback_4_4<true, R, Arg1, Arg2, Arg3, Arg4>(function, arg1, arg2, arg3, arg4);
}

template <class R, class Arg1, class Arg2, class Arg3, class Arg4>
inline typename _FunctionResultCallback_4_4<false, R, Arg1, Arg2, Arg3, Arg4>::base*
NewPermanentCallback(R (*function)(Arg1, Arg2, Arg3, Arg4), Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
  return new _FunctionResultCallback_4_4<false, R, Arg1, Arg2, Arg3, Arg4>(function, arg1, arg2, arg3, arg4);
}

}  // namespace base

#endif  // BASE_CALLBACK_SPEC_H_
